# MongoDB Summary

В MongoDB структура (иерархия) базы данных выглядит следующим образом, от большего к меньшему:

1.  **Server (инстанс MongoDB)**  
    Запущенный процесс mongod. На одном сервере может быть несколько баз данных.
2.  **Database (База данных)**  
    Логическая группировка коллекций. Каждая база имеет собственные файлы хранения (внутри каталога данных сервера).  
    Примеры: `admin`, `local`, `my_app_db`.
3.  **Collection (Коллекция)**  
    Аналог таблицы в реляционных СУБД, но схема не фиксирована.  
    В одной коллекции документы могут иметь разную структуру.  
    Примеры: `users`, `orders`, `events`.
4.  **Document (Документ)**  
    Аналог строки таблицы, но представляет собой **JSON-подобный BSON-объект**.  
    Это основная единица данных в MongoDB.  
    Пример:
    ```
    {
        "_id": ObjectId("..."),
        "name": "John",
        "age": 30,
        "roles": ["admin", "editor"]
    }
    ```
5.  **Field (Поле)**  
    Аналог столбца, но поля могут быть вложенными.  
    Пример:  
    `address.city = "Brussels"`.
6.  **Embedded Document / Array (Вложенные документы и массивы)**  
    MongoDB поддерживает вложенность произвольной глубины.  
    Это принципиальное отличие от SQL.

* * *

### Итоговая иерархия (кратко)

```
Server
 └── Database
       └── Collection
             └── Document
                   └── Field (в т.ч. вложенные документы и массивы)
```

## Пример:
Ниже приведён простой, intuitively understandable учебный пример, показывающий полную иерархию MongoDB: сервер → база данных → коллекции → документы → поля.

* * *

1\. Server
----------

Предположим, у нас запущен MongoDB-сервер.

* * *

2\. Database: `shop`
--------------------

База данных **shop** предназначена для хранения данных интернет-магазина.

Внутри неё есть коллекции:

*   `products`
*   `customers`
*   `orders`

* * *

3\. Collections и примеры документов
------------------------------------

### Коллекция `products`

Хранит товары.

Документ 1:

```
{
    "_id": ObjectId("64fa12..."),
    "name": "Laptop X10",
    "price": 1200,
    "specs": {
        "cpu": "Intel i7",
        "ram_gb": 16,
        "storage": "512GB SSD"
    },
    "tags": ["electronics", "laptop"]
}
```

Документ 2:

```
{
    "_id": ObjectId("64fa13..."),
    "name": "Mouse A5",
    "price": 25,
    "tags": ["electronics", "accessory"]
}
```

* * *

### Коллекция `customers`

Хранит клиентов.

Документ:

```
{
    "_id": ObjectId("64fa20..."),
    "name": "Alice Brown",
    "email": "alice@example.com",
    "address": {
        "city": "Brussels",
        "street": "Main Street 15"
    },
    "loyalty_points": 120
}
```

* * *

### Коллекция `orders`

Хранит заказы. Здесь сразу видно, что документы могут ссылаться на другие документы.

Документ:

```
{
    "_id": ObjectId("64fa50..."),
    "customer_id": ObjectId("64fa20..."),
    "items": [
        {
            "product_id": ObjectId("64fa12..."),
            "quantity": 1,
            "price": 1200
        },
        {
            "product_id": ObjectId("64fa13..."),
            "quantity": 2,
            "price": 25
        }
    ],
    "total": 1250,
    "date": ISODate("2024-01-10T10:00:00Z")
}
```

* * *

4\. Что представляет собой иерархия
-----------------------------------

### Server

Хостит множество баз.

### Database: `shop`

Хранит всё, что относится к магазину.

### Collections

*   `products` — список товаров
*   `customers` — клиенты
*   `orders` — заказы

Каждая коллекция — логическое объединение документов.

### Documents

Каждый документ — самостоятельная JSON-подобная запись (BSON).  
Структуры внутри одной коллекции могут отличаться.

### Fields

Поля могут быть:

*   простыми (строка, число)
*   вложенными документами
*   массивами
*   массивами документов

* * *

5\. Мини-сводка иерархии на примере
-----------------------------------

```
Server
└── Database: shop
      ├── Collection: products
      │      ├── Document: Laptop X10
      │      └── Document: Mouse A5
      │
      ├── Collection: customers
      │      └── Document: Alice Brown
      │
      └── Collection: orders
             └── Document: Order #64fa50...
```

Этот пример показывает, **что именно** хранится на каждом уровне структуры MongoDB и как документы связаны между собой.

## Связи:
В MongoDB **нет встроенных “реляционных связей”**, как в SQL.  
Но связи **организуются**, и делают это двумя способами:

1.  **Reference (ссылка)** — через идентификаторы документов
2.  **Embedding (вложение)** — один документ физически включает другой

Это фундаментальный принцип моделирования в MongoDB.

Ниже — подробное описание.

* * *

1\. Reference (ссылки между коллекциями)
========================================

Это аналог **“внешнего ключа”**, но MongoDB не проверяет и не поддерживает целостность автоматически.

Пример: коллекция `orders` хранит ссылку на документ в коллекции `customers`:

```
{
    "_id": ObjectId("o1"),
    "customer_id": ObjectId("c1"),   // ссылка на документ в customers
    "total": 1250
}
```

А в `customers` есть документ с `_id: ObjectId("c1")`.

Характеристики ссылок:

*   связь **логическая**, не гарантируется сервером;
*   JOIN в MongoDB отсутствует, но есть оператор `$lookup` в агрегировании;
*   удобно, если данные большие или часто обновляются отдельно.

Используется, когда:

*   данные живут отдельно (клиенты, товары);
*   документы большие;
*   нужна масштабируемость.

* * *

2\. Embedding (вложенные документы)
===================================

Другой путь — **вложить** связанные данные прямо внутрь документа.

Пример заказа:

```
{
    "_id": ObjectId("o1"),
    "customer": {
        "name": "Alice",
        "email": "alice@example.com"
    },
    "items": [
        { "product": "Laptop X10", "qty": 1, "price": 1200 },
        { "product": "Mouse A5", "qty": 2, "price": 25 }
    ],
    "total": 1250
}
```

Вложенные документы и массивы — норма в MongoDB.

Используется, когда:

*   данные редко меняются отдельно;
*   нужно очень быстро читать всю сущность целиком;
*   объём данных небольшой.

* * *

3\. Что именно «связывается» в MongoDB?
=======================================

Связи существуют только между **документами**.  
Коллекции сами по себе не имеют ссылок.  
Но в одной коллекции документы часто хранят ObjectId других документов из другой коллекции.

Иерархия такая:

```
Database
  ├── Collection A
  │       └── Document A1  --> contains references (ObjectId) to Documents in B
  │
  └── Collection B
          └── Document B1
```

* * *

4\. Пример: связи в реальном приложении
=======================================

### Customers

```
{
    "_id": ObjectId("c1"),
    "name": "Alice"
}
```

### Products

```
{
    "_id": ObjectId("p10"),
    "name": "Laptop X10",
    "price": 1200
}
```

### Orders (referencing both)

```
{
    "_id": ObjectId("o1"),
    "customer_id": ObjectId("c1"),
    "items": [
        {
            "product_id": ObjectId("p10"),
            "qty": 1
        }
    ]
}
```

* * *

5\. Когда что использовать?
===========================

### Embedding (вложение)

*   Данные читаются вместе?  
    Вкладывать.
*   Один-ко-многим, но количество “многих” маленькое (например, 3–10)?  
    Вкладывать.

### References (ссылки)

*   Данные очень большие; вложение приведёт к росту документа.
*   Один-ко-многим с **большим количеством** элементов.
*   Данные меняются независимо.

* * *

## ID:
В MongoDB поле `_id` является **первичным ключом документа**. Оно существует **в каждом документе** и гарантирует уникальность внутри коллекции.

Ниже — как именно устроен `_id`, как он генерируется и когда назначается автоматически.

* * *

1\. Назначается ли `_id` автоматически?
=======================================

Да.

Если вы вставляете документ без `_id`, MongoDB **автоматически создаёт**:

```
"_id": ObjectId("...")
```

Это значение генерирует драйвер MongoDB (или сервер), и оно уникально.

Вы можете задать `_id` вручную.  
Если вставить документ с существующим `_id`, произойдёт ошибка дубликата.

* * *

2\. Что такое ObjectId
======================

Тип `_id` по умолчанию — **ObjectId**, специальный 12-байтовый бинарный идентификатор.

В JSON выглядит как:

```
ObjectId("64fa12de89f0ab1234567890")
```

* * *

3\. Из чего состоит ObjectId (внутреннее устройство)
====================================================

ObjectId = 12 байт:

1.  **4 байта** — timestamp (секунды Unix Epoch)
2.  **5 байт** — случайный уникальный узел (machine + random data)
3.  **3 байта** — счётчик, инкрементируемый для каждой вставки

Таким образом:

```
[ timestamp | random | counter ]
```

Характеристики:

*   устойчивость к коллизиям,
*   сортируются по времени вставки (важно для индексов),
*   можно определить примерное время создания документа.

* * *

4\. Время создания из ObjectId
==============================

Преимущество: по `_id` можно узнать timestamp:

Например:

`ObjectId("64fa12de89f0ab1234567890")`

Первая часть `"64fa12de"` — это hex-значение Unix-времени.

MongoDB shell:

```
ObjectId("64fa12de89f0ab1234567890").getTimestamp()
```

* * *

5\. Можно ли использовать другой тип для `_id`?
===============================================

Да.

Вместо стандартного ObjectId можно использовать:

*   строку (например `"user_1234"`)
*   число
*   UUID
*   любой BSON-тип, кроме массивов

Но:

*   придётся самому генерировать уникальность,
*   утратите сортировку по времени.

* * *

6\. Когда лучше оставить ObjectId?
==================================

В 95% случаев — всегда.

Причины:

*   уникален без конфигурации,
*   легко индексируется,
*   быстро генерируется,
*   хранится компактно (12 байт),
*   работает без гонок и распределённых коллизий.

* * *

7\. Когда вручную задают `_id`
==============================

Типичные кейсы:

*   Natural keys (например, код страны ISO: "BE").
*   Единый идентификатор из внешней системы.
*   UUIDv4, если требуется глобальная уникальность между разными системами.

* * *

### 1\. Краткое описание структуры (иерархии) MongoDB

*   **База данных (Database)** — контейнер для коллекций, например: `library`.
*   **Коллекция (Collection)** — аналог таблицы в SQL, хранит документы, например: `books`.
*   **Документ (Document)** — основной объект хранения, аналог строки в таблице, хранится в формате BSON (по сути — расширенный JSON).
*   **Поля (Fields)** — ключ-значение внутри документа, например: `"title": "War and Peace"`.

**Иерархия**:  
База данных → Коллекции → Документы → Поля

* * *

## Поиск:
В MongoDB поиск по коллекциям осуществляется через запросы по значениям полей документов (аналог WHERE в SQL). Можно искать по любым полям, в том числе по вложенным.

**Индексы в MongoDB работают примерно как в SQL:**

*   Для быстрого поиска по полям (особенно не по `_id`) индексы нужно создавать вручную.
*   Без индекса поиск будет делать полный перебор документов (full collection scan), что медленно на больших коллекциях.
*   Создать можно обычные, составные, уникальные, текстовые, гео-индексы и др.

**Пример:**

```python
# Поиск всех студентов с именем "Ivan Ivanov"
db.students.find({"name": "Ivan Ivanov"})

# Создание индекса по полю name (ускорит поиск выше)
db.students.create_index("name")
```

**Основные моменты:**

*   Индекс по `_id` создаётся автоматически.
*   Для других часто используемых в поиске полей индексы надо создавать вручную.
*   Можно создавать составные индексы для поиска по нескольким полям одновременно.

**Вывод:**  
Если коллекция небольшая — можно обойтись без индексов. Для больших и часто используемых полей индексы нужны, иначе поиск будет медленным.

# Команды поиска:
Ниже — строгое, полное объяснение, как работает поиск в MongoDB, какие команды используются, какие ограничения существуют, и почему нельзя искать «только по значению без указания поля».

* * *

1\. Базовая команда поиска
==========================

Основная команда:

```
db.<collection>.find(<filter>, <projection>)
```

Пример:

```
db.users.find({ age: 30 })
```

Возвращает **документы** из коллекции `users`, у которых поле `age = 30`.

* * *

2\. Поиск работает **только внутри одной коллекции**
====================================================

MongoDB НЕ выполняет поиск одновременно по нескольким коллекциям  
(за исключением `$unionWith` внутри агрег pipeline, но это редкий случай и не «обычный поиск»).

Структура:

*   Вы выбираете коллекцию: `db.products`
*   И ищете документы в ней.

MongoDB **не может** искать среди всех коллекций сразу «как Google по базе».  
Нужно явно указывать коллекцию.

* * *

3\. Поиск осуществляется по **полям** (в т.ч. вложенным)
========================================================

Можно искать по:

*   простым полям
*   вложенным полям (`address.city`)
*   элементам массивов
*   диапазонам
*   регулярным выражениям

Примеры:

```
db.users.find({ "address.city": "Brussels" })
```

```
db.orders.find({ total: { $gt: 1000 } })
```

```
db.books.find({ title: /war/i })   // regex
```

* * *

4\. Ищутся **только документы**
===============================

MongoDB — документная БД.  
Результатом поиска всегда является **множество документов** из коллекции.

Коллекции и базы данных сама по себе не возвращает — это только контейнеры.

* * *

5\. Можно ли искать _без указания имени поля_, только по значению?
==================================================================

**Нет — только по значению без указания поля искать нельзя.**.

# Full scan:
**Full scan** (в MongoDB — _collection scan_, сокращённо _COLLSCAN_) — это ситуация, когда сервер **перебирает все документы коллекции от первого до последнего**, чтобы выполнить запрос.

Это аналог **full table scan** в SQL.

* * *

1\. Что означает full scan
==========================

MongoDB не нашла подходящий индекс для условия поиска → значит, **нужно проверить каждый документ вручную**.

По сути:

```
for each document in collection:
    if document matches filter:
        return it
```

* * *

2\. Когда происходит full scan
==============================

Когда:

1.  Нет индекса по полю, которое используется в запросе:
    ```
    db.users.find({ age: 30 })
    ```
    и индекса `age` нет → full scan.
2.  Используются условия, которые не могут применить индекс  
    (например, поиск по регулярному выражению, начинающемуся не с фиксированной строки):
    ```
    db.products.find({ name: /phone/ })     // index НЕ используется
    ```
3.  Используются вычисления, функции, выражения, которые требуют просмотра всех документов.
4.  Фильтр слишком неопределённый, и индекс плохо помогает.

* * *

3\. Почему full scan плохо
==========================

*   Долго на больших коллекциях (миллионы+ документов).
*   Нагрузка на CPU.
*   Нагрузка на дисковую подсистему / память.
*   Блокирует ресурсы и может замедлять всю БД.

Поэтому создание индексов — критично важно.

* * *

4\. Как увидеть, что используется full scan
===========================================

Команда:

```
db.collection.find({ ... }).explain("executionStats")
```

Если в результате вы увидите:

```
"stage": "COLLSCAN"
```

— это и есть full scan.

Если используется индекс будет:

```
"stage": "IXSCAN"
```

* * *

5\. Full scan — это всегда плохо?
=================================

Нет.

Если коллекция:

*   маленькая (до 1000–10000 документов),
*   редко используется,
*   или запрос разовый,

то full scan может быть абсолютно нормальным решением.

Но для больших коллекций **обязательно** нужны индексы.

* * *

Как выглядит ссылка в документе?
====================================

Обычное поле, содержащее ObjectId:

```
"customer_id": ObjectId("c1")
```

MongoDB не знает, что это именно «ссылка» — это просто значение.  
Никакой автоматической проверки целостности нет.

* * *

## Аанлог Join (lookup):
Ниже — точный и рабочий способ получить **номер заказа**, при условии что:

*   в коллекции **orders** НЕТ полей `name` или `tags`;
*   есть только ссылки на:
    *   `customer_id` → в коллекцию **customers**, где есть `name`;
    *   `items.product_id` → в коллекцию **products**, где есть `tags`.

То есть требуется сделать «двойной JOIN»:  
**orders → customers** и **orders → products**.

MongoDB делает это через **$lookup**.

* * *

1\. Структура (для понимания)
=============================

### customers

```
{
  _id: ObjectId("c1"),
  name: "Alice"
}
```

### products

```
{
  _id: ObjectId("p1"),
  name: "Laptop",
  tags: ["electronics", "laptop"]
}
```

### orders

```
{
  _id: ObjectId("o1"),
  customer_id: ObjectId("c1"),
  items: [
      { product_id: ObjectId("p1"), qty: 1 }
  ]
}
```

* * *

2\. Задача
==========

Найти **\_id заказа**, в котором:

*   имя покупателя = `"Alice"`
*   хотя бы один товар имеет tag `"electronics"`

* * *

3\. Решение (агрегация с двумя $lookup)
=======================================

```
db.orders.aggregate([
    {
        $lookup: {
            from: "customers",
            localField: "customer_id",
            foreignField: "_id",
            as: "customer"
        }
    },
    { 
        $unwind: "$customer" 
    },
    {
        $match: { "customer.name": "Alice" }
    },

    {
        $lookup: {
            from: "products",
            localField: "items.product_id",
            foreignField: "_id",
            as: "products"
        }
    },

    {
        $match: { "products.tags": "electronics" }
    },

    {
        $project: {
            _id: 1
        }
    }
])
```

* * *

4\. Что делает этот код
=======================

1.  **Первый $lookup** подтягивает данные из customers.
2.  **$unwind** превращает массив customer в объект.
3.  **$match** ищет customer.name = "Alice".
4.  **Второй $lookup** подтягивает список товаров, связанных с заказом.
5.  **$match** ищет хотя бы один товар с tag "electronics".
6.  **$project** оставляет только номер заказа (`_id`).

* * *

5\. Пример результата
=====================

```
{ "_id": ObjectId("o1") }
```

* * *

6\. Важное замечание
====================

MongoDB **не делает автоматические JOIN**, поэтому:

*   ни поле `name`,
*   ни поле `tags`  
    — даже если логически относятся к заказу — не могут быть найдены без `$lookup`.

* * *

Что именно делает `$lookup`
===========================

*   Выполняет **динамическое соединение** (аналог LEFT JOIN в SQL).
*   Читает документы из другой коллекции.
*   Добавляет результат во **временное поле** (обычно `as: "something"`), существующее только внутри результата запроса.

После завершения агрегации данные исчезают — они никогда не записываются обратно в коллекции.

* * *

Пример для понимания
====================

Если выполнить:

```
db.orders.aggregate([
  { 
    $lookup: {
      from: "customers",
      localField: "customer_id",
      foreignField: "_id",
      as: "customer"
    }
  }
])
```

То MongoDB:

1.  Читает каждый документ в `orders`.
2.  Для каждого документа ищет соответствующих клиентов.
3.  Возвращает **новые виртуальные документы**, в которых есть поле `"customer"`.

**Но коллекции `orders` и `customers` остаются прежними.**

* * *



* * *

1\. Список всех коллекций в базе
================================

```
show collections
```

или программно:

```
db.getCollectionNames()
```

* * *

2\. Список документов в коллекции
=================================

### Все документы:

```
db.myCollection.find()
```

### Ограничение по количеству (лучше для больших коллекций):

```
db.myCollection.find().limit(20)
```

### Подсчитать количество документов:

```
db.myCollection.countDocuments()
```

* * *

3\. Список полей в ОДНОМ документе
==================================

Возьмём первый документ:

```
var doc = db.myCollection.findOne()
Object.keys(doc)
```

Если нужно увидеть поля вложенных объектов:

```
printjson(doc)
```

* * *

4\. Как получить **полный список уникальных имён всех полей во всей коллекции**
===============================================================================



Вариант 1. Простой (только верхний уровень полей)
-------------------------------------------------

```
db.myCollection.aggregate([
  { $project: { keys: { $objectToArray: "$$ROOT" } } },
  { $unwind: "$keys" },
  { $group: { _id: null, allKeys: { $addToSet: "$keys.k" } } }
])
```

Результат будет таким:

```
{
  "_id": null,
  "allKeys": [
     "_id",
     "name",
     "age",
     "tags",
     "address",
     "created_at",
     ...
  ]
}
```

* * *



## Поиск:
Ниже — точное объяснение, **как выполнять поиск по полю в оболочке MongoDB** (mongosh или старой mongo). Это всегда делается через команду:

```
db.<collection>.find(<условие>)
```

* * *

1\. Базовый поиск по одному полю
================================

```
db.users.find({ name: "Alice" })
```

Это вернёт все документы из коллекции `users`, где поле `name` равно "Alice".

* * *

2\. Поиск с условием (операторы сравнения)
==========================================

```
db.users.find({ age: { $gt: 25 } })
```

Другие операторы: `$lt`, `$gte`, `$ne`, `$in`, `$regex`, и т.д.

* * *

3\. Поиск по вложенному полю
============================

Если документ:

```
{
  name: "Alice",
  address: { city: "Brussels", zip: 1000 }
}
```

Поиск:

```
db.users.find({ "address.city": "Brussels" })
```

* * *

4\. Поиск по нескольким условиям
================================

Все условия — через JSON:

```
db.users.find({ name: "Alice", age: 30 })
```

MongoDB интерпретирует это как AND.

* * *

5\. Поиск по одному из значений (OR)
====================================

```
db.users.find({
  $or: [
    { name: "Alice" },
    { age: 30 }
  ]
})
```

* * *

6\. Поиск по массиву (точное значение)
======================================

```
db.products.find({ tags: "electronics" })
```

Если массив содержит элемент "electronics", документ будет найден.

* * *

7\. Поиск по регулярному выражению
==================================

```
db.products.find({ name: /phone/i })
```

* * *

8\. Просмотр одного документа
=============================

```
db.users.findOne({ email: "alice@example.com" })
```

* * *

9\. Форматированный вывод (для удобства)
========================================

```
db.users.find({ age: 30 }).pretty()
```

* * *

10\. Пример полного запроса в реальной оболочке
===============================================

Если коллекция называется `orders`, и вы хотите найти все заказы, созданные сегодня:

```
db.orders.find({ date: { $gte: ISODate("2024-01-01") } })
```

* * *

Если вы прямо сейчас сидите в mongosh, запуск выглядит так:
===========================================================

```
test> db.users.find({name: "Alice"})
[
  {
    _id: ObjectId("656..."),
    name: 'Alice',
    age: 30
  }
]
```

* * *

Важно
=====

Поиск выполняется **всегда по коллекции**, поэтому перед командой `find` должно быть:

```
db.<collectionName>
```

* * *

Если хотите, могу дать короткий список 10 самых часто используемых запросов `find()` с реальными примерами.

# Разное

mongosh поддерживает параметр `--file`:

```
mongosh --file shop_seed.js
```

Но важно: если требуется подключение через URI:

```
mongosh "mongodb://localhost:27017" --file shop_seed.js
```

Оба варианта работают одинаково.



Также можно `mongosh < shop_seed.js`

* * *

Сортировка в `find()`
=========================

Синтаксис:

```
db.collection.find(<фильтр>).sort(<поля>)
```

Примеры:

По одному полю — по возрастанию
-------------------------------

```
db.products.find().sort({ price: 1 })
```

По одному полю — по убыванию
----------------------------

```
db.products.find().sort({ price: -1 })
```

По двум полям
-------------

```
db.customers.find().sort({ city: 1, name: 1 })
```

MongoDB выполняет сортировку **в указанном порядке**, как ORDER BY в SQL.

* * *

2\. Сортировка внутри агрегирования
===================================

Используется стадия `$sort`:

```
db.orders.aggregate([
    { $sort: { total: -1 } }
])
```

Можно сортировать после `$match`, `$lookup`, `$group`, и т.д.

* * *

3\. Особенности сортировки
==========================

### 3.1. Чтобы сортировка была быстрой — нужен индекс

Например, при сортировке по `price` рекомендуется создать индекс:

```
db.products.createIndex({ price: 1 })
```

Без индекса, MongoDB может выполнять **in-memory sort** со следующими ограничениями:

*   лимит сортировки в RAM: **100 МБ**
*   если превышено — ошибка:
    ```
    Sort exceeded memory limit of 100MB
    ```

Решение:

```
db.collection.aggregate([...], { allowDiskUse: true })
```

* * *

4\. Сортировка по вложенным полям
=================================

Работает так же:

```
db.customers.find().sort({ "address.city": 1 })
```

* * *

5\. Сортировка по массивам
==========================

MongoDB берёт первый элемент массива или использует особые правила сравнения.  
Пример:

```
db.products.find().sort({ tags: 1 })
```

Обычно сортируют по числам/строкам, а не по массивам.

* * *

6\. Сортировка с limit и skip
=============================

Полный аналог SQL LIMIT/OFFSET:

```
db.products.find()
           .sort({ price: 1 })
           .skip(10)
           .limit(5)
```

* * *

7\. Проверка плана сортировки
=============================

Чтобы понять, используется ли индекс для сортировки:

```
db.products.find().sort({ price: 1 }).explain("executionStats")
```

Если видите:

```
"stage": "SORT"
```

индекс НЕ используется.

Если:

```
"stage": "IXSCAN"
```

индекс используется.

* * *



## Types:
В MongoDB данные хранятся в формате **BSON** (Binary JSON). У BSON есть свой набор типов. Ниже — основные типы, которые реально используются в приложениях, с пояснением «что это» и «зачем».

Я сгруппирую их по практической пользе, а не по внутренним кодам BSON.

* * *

1\. Строки
----------

### `String` (BSON type 2)

*   Примеры:
    ```js
    { name: "Alice" }
    { city: "Brussels" }
    ```
*   Использование:
    *   имена, адреса, email, любые текстовые поля;
    *   удобен для фильтрации и сортировки.
*   Особенности:
    *   кодировка UTF-8;
    *   для полнотекстового поиска делают **text index** по строковым полям.

* * *

2\. Числа
---------

MongoDB различает **32-битные int**, **64-битные long**, **double** и другие числовые типы.

### `Int32` (BSON type 16)

*   Примеры:
    ```js
    { age: 30 }
    { quantity: 5 }
    ```
*   Использование:
    *   целые числа в диапазоне −2,147,483,648 … 2,147,483,647;
    *   ID, счетчики, количество штук.

### `Int64` / `Long` (BSON type 18)

*   Примеры:
    ```js
    { views: NumberLong("1234567890123") }
    ```
*   Использование:
    *   большие целые: просмотры, ID из внешних систем, UNIX-timestamps в миллисекундах;
*   В shell требуется обёртка `NumberLong(...)`.

### `Double` (BSON type 1)

*   Примеры:
    ```js
    { price: 19.99 }
    { latitude: 50.8503 }
    ```
*   Использование:
    *   числа с плавающей точкой: цены, координаты, показатели.
*   Особенность: стандартный “double” IEEE-754, возможны ошибки округления (как в любом float’е).

### `Decimal128` (BSON type 19)

*   Примеры:
    ```js
    { account_balance: NumberDecimal("12345.67") }
    ```
*   Использование:
    *   финансовые суммы, когда **нужна точная десятичная арифметика** (банковские продукты, биллинг).
*   Преимущество: избегает ошибок округления double.

* * *

3\. Логический тип
------------------

### `Boolean` (BSON type 8)

*   Примеры:
    ```js
    { isActive: true }
    { deleted: false }
    ```
*   Использование:
    *   флаги состояний, признаки, статусы (вкл/выкл).

* * *

4\. Даты и время
----------------

### `Date` (BSON type 9)

*   Примеры:
    ```js
    { created_at: ISODate("2024-01-10T10:00:00Z") }
    ```
*   Использование:
    *   время создания/обновления;
    *   даты событий, заказов, логов.
*   Особенности:
    *   хранится как количество миллисекунд с 1970-01-01 UTC;
    *   всегда в UTC, формат в shell — `ISODate(...)`;
    *   есть операторы `$gt`, `$lt`, `$gte`, `$lte` для сравнения.

### `Timestamp` (BSON type 17)

*   Примеры:
    ```js
    { ts: Timestamp(1694000000, 1) }
    ```
*   Использование:
    *   в основном для внутренних задач MongoDB (репликация, oplog);
    *   редко применяют в пользовательских моделях, чаще Date достаточно.

* * *

5\. Объекты и вложенные структуры
---------------------------------

### `Document` / `Embedded Document` (BSON type 3)

*   Примеры:
    ```js
    {
      name: "Alice",
      address: {
        city: "Brussels",
        street: "Main Street 15"
      }
    }
    ```
*   Использование:
    *   вложенные структуры (адрес, настройки, параметры);
    *   основа документно-ориентированной модели.
*   Позволяет:
    *   искать по вложенным полям (`"address.city": "Brussels"`),
    *   хранить связанные данные прямо внутри документа (embedding).

### `Array` (BSON type 4)

*   Примеры:
    ```js
    { tags: ["electronics", "laptop"] }
    { items: [{ product_id: ..., qty: 2 }, { product_id: ..., qty: 1 }] }
    ```
*   Использование:
    *   списки значений (теги, роли, телефоны);
    *   массивы поддокументов (позиции заказа, комментарии).
*   Есть операторы: `$in`, `$all`, `$elemMatch`, `$size`.

* * *

6\. Объекты идентификаторов и ключей
------------------------------------

### `ObjectId` (BSON type 7)

*   Пример:
    ```js
    { _id: ObjectId("66c100c10000000000000101") }
    ```
*   Использование:
    *   стандартный тип для `_id` (первичный ключ документа);
    *   часто применяется как внешний ключ в других коллекциях.
*   Структура:
    *   12 байт: timestamp + random + counter;
    *   сортируется по времени создания.

* * *

7\. Специальные и служебные типы
--------------------------------

### `Null` (BSON type 10)

*   Пример:
    ```js
    { middle_name: null }
    ```
*   Использование:
    *   пустое значение / «нет данных»;
    *   можно фильтровать: `{ middle_name: null }`.

### `Undefined` (BSON type 6) — устаревший

*   Не рекомендуется к использованию;
*   Оставлен ради совместимости, в нормальных моделях не применяют.

### `Symbol` (BSON type 14) — устаревший

*   Для совместимости, используется крайне редко;
*   В современных приложениях избегают.

### `MinKey` (BSON type -1) и `MaxKey` (BSON type 127)

*   Использование:
    *   служебные значения для сравнений, когда нужно явно «меньше всего» или «больше всего».
*   Пример:
    ```js
    { field: { $gt: MinKey } }
    ```
*   Практически нужны редко, больше для специальных случаев и внутренних операций.

* * *

8\. Двоичные данные
-------------------

### `Binary` (BSON type 5)

*   Примеры:
    ```js
    { fileData: BinData(0, "...base64...") }
    ```
*   Использование:
    *   хранение двоичных данных: зашифрованные блоки, хэши, небольшие файлы.
*   Замечание:
    *   для крупных файлов обычно используют **GridFS**, а не обычное поле.

* * *

9\. Специальные типы для кода
-----------------------------

### `JavaScript code` (BSON type 13) и `JavaScript with scope` (type 15)

*   Примеры:
    ```js
    { code: Code("function(x) { return x * 2; }") }
    ```
*   Использование:
    *   старые механизмы server-side JavaScript, custom functions.
*   Сейчас:
    *   практически не рекомендуются к использованию в реальных моделях;
    *   применяются крайне редко (вместо этого — логика в приложении).

* * *

10\. Регулярные выражения
-------------------------

### `Regular Expression` (BSON type 11)

*   Пример:
    ```js
    { name: /Alice/i }
    ```
*   Использование:
    *   поиск по шаблону в строках;
*   На практике:
    *   в запросах просто пишут `/pattern/`, а не создают такие поля в документах;
    *   в качестве значения в документ сохраняют редко.

* * *

11\. Типы для ссылок и DBRef (устаревшая практика)
--------------------------------------------------

### `DBRef`

*   Структура вида:
    ```js
    { "$ref": "collectionName", "$id": ObjectId("..."), "$db": "dbName" }
    ```
*   Использование:
    *   старый механизм хранения ссылок на другие документы.
*   Сейчас:
    *   фактически вытеснен простой схемой: `field_id: ObjectId("...")`;
    *   DBRef не даёт никаких автоматических join и не стоит его использовать.

* * *

12\. Геоданные (тип формально `Object` + специальные форматы)
-------------------------------------------------------------

Специальный тип **BSON GeoJSON** как таковой не отдельный, это обычный `Document`, но в специальном формате.

Пример:

```js
{
  location: {
    type: "Point",
    coordinates: [ 4.3517, 50.8503 ] // [долгота, широта]
  }
}
```

Использование:

*   геоиндексы (`2dsphere`);
*   поиск:
    *   объектов «рядом» (`$near`)
    *   в полигонах (`$geoWithin`)
    *   на определённом расстоянии.

* * *

Итоговая «карта типов» по назначению
------------------------------------

*   **Текст**: `String`
*   **Целые числа**: `Int32`, `Int64/Long`
*   **Дробные числа**: `Double`
*   **Точная десятичная арифметика**: `Decimal128`
*   **Логика**: `Boolean`
*   **Время**: `Date`
*   **Связи и ключи**: `ObjectId`
*   **Сложные структуры**: `Document`, `Array`
*   **Финансы / критическая точность**: `Decimal128`
*   **Файлы / байты**: `Binary` или GridFS
*   **Редкие/служебные**: `Timestamp`, `MinKey`, `MaxKey`, `Null`, устаревшие (`Undefined`, `Symbol`, DBRef, JavaScript code)

## Ограничения:
* * *

1\. String — ограничения и особенности
======================================

### 1) Ограничение по длине строки

У BSON нет отдельного лимита “на строку”, но есть общий лимит на документ:

**Максимальный размер одного BSON-документа — 16 MB.**

Следовательно, строка **не может превышать ~16 MB** минус остальные поля документа.

Практически:

*   строки до 1–2 MB — рабочий вариант,
*   строки размером в десятки MB — нельзя (переходят в GridFS).

### 2) Кодировка: строго UTF-8

MongoDB хранит **только UTF-8**.  
ASCII — подмножество UTF-8, проблем нет.

### 3) Строка НЕ может быть NULL

`"text": null` означает **значение null**, но поле считается **не строкой**, а типом Null.

### 4) Ограничения по индексам

Индексируемые строки подчиняются лимиту размера ключа:

**Индексируемое значение ≤ 1024 байт.**

Если строка длинная, её нельзя нормально индексировать.

### 5) Ограничения по сортировке

Сортировка больших строк — дорогая операция, требует RAM.

* * *

2\. Decimal128 — ограничения, диапазоны, особенности
====================================================

Тип `Decimal128` — это **IEEE 754-2008 128-bit decimal floating point**.

Это единственный тип в MongoDB, пригодный для **точных денежных расчётов**, где `Double` давать нельзя.

### Ограничения и свойства Decimal128:

### 1) Разрядность

*   До **34 значащих цифр** (precision: 34 digits).
*   Диапазон порядка: от ~10⁻⁶¹⁴⁵ до 10⁶¹¹⁴.

То есть можно хранить, например:

```
123456789012345678901234567890.1234
```

— без потери точности.

### 2) Поддерживает десятичный формат без ошибок округления double

В отличие от Double:

```
0.1 + 0.2 != 0.3   // для double
```

Для Decimal128:

```
NumberDecimal("0.1") + NumberDecimal("0.2") == NumberDecimal("0.3")
```

### 3) Переполнение / NAN

Поддерживает:

*   +Infinity
*   \-Infinity
*   NaN

### 4) Ограничения при сравнении

Сравнение Decimal128 и Double — **разные типы**, Mongo их не приводит автоматически.

Например:

```
{ amount: 10.5 }   // double
{ amount: NumberDecimal("10.5") }  // decimal128
```

Это разные значения.

### 5) Ограничения при индексации

Всё корректно, Decimal128 индексируется нормально, но **нельзя смешивать типы** на одном поле (double + decimal).

* * *

Как задать Decimal128 вместо Double
===================================

MongoDB **никогда сама не создаёт Decimal128**, только Double по умолчанию.

Чтобы задать Decimal128, нужно писать:

### В mongosh:

```
{ amount: NumberDecimal("123.45") }
```

### В insertMany():

```
db.orders.insertOne({
    price: NumberDecimal("19.99")
})
```

### В update():

```
db.accounts.updateOne(
    { _id: 1 },
    { $set: { balance: NumberDecimal("1500.00") } }
)
```

### В JavaScript (Node.js + driver):

```
const { Decimal128 } = require("mongodb");

collection.insertOne({
    amount: Decimal128.fromString("123.45")
});
```

### В Python (PyMongo):

```
from bson.decimal128 import Decimal128

collection.insert_one({
    "amount": Decimal128("123.45")
})
```

### В JSON невозможно

JSON не поддерживает Decimal128.  
Поэтому все импорты JSON → Compass будут превращать числа в Double.

* * *

3\. Null — ограничения и особенности
====================================

Тип `Null` в MongoDB — это **отдельный BSON-тип**, не строка и не undefined.

Пример:

```
{ middle_name: null }
```

### Ограничения:

### 1) `null` — это значение, не отсутствие поля

Это важно:

```
{ middle_name: null }
```

и

```
{ }   // поля нет
```

— не одно и то же.

### 2) Поиск по null возвращает оба варианта:

```
db.users.find({ middle_name: null })
```

найдёт документы:

*   где значение null
*   **и где поле отсутствует**

Чтобы различать:

```
{ middle_name: { $exists: false } }     // поле отсутствует
{ middle_name: null }                   // null или отсутствует
```

Если нужно строго значение null:

```
{ middle_name: { $type: 10 } }
```

Тип 10 — это BSON Null.

### 3) Null не индексируется иначе, чем обычное значение

Можно индексировать поля содержащие null, но:

*   все null считаются одинаковым ключом для индекса.

### 4) Нельзя использовать null для сравнения как строку или число

Null имеет собственный тип, Mongo не приводит его.

* * *

Краткий итог
============

String — ограничения:
---------------------

*   максимум ~16 MB (в рамках документа)
*   индексируемое значение ≤ 1024 байт
*   только UTF-8
*   длинные строки плохо сортируются

Decimal128 — ограничения:
-------------------------

*   максимум 34 значащих цифры
*   диапазон порядка ±10⁶¹¹⁴
*   точная десятичная арифметика
*   нельзя смешивать Double и Decimal на одном поле

Null — ограничения:
-------------------

*   отличать `null` и отсутствие поля
*   `{field: null}` находит оба варианта
*   тип `null` — BSON type 10
*   допустим в любом поле, но не равен 0, false или "".

Как задать Decimal128?
----------------------

*   В mongosh:
    ```
    NumberDecimal("123.45")
    ```
*   В драйверах — через соответствующие функции (`Decimal128.fromString()` и т. п.)

* * *

Если нужно, могу сделать таблицу: **когда лучше использовать double, а когда decimal128**, или показать типичные ошибки разработчиков, связанных с decimal/null/string.

## Response:
В MongoDB для хранения файлов есть два варианта:

1.  **Хранить файл напрямую в документе** (в поле типа `Binary` / `BinData`)
2.  **Использовать GridFS** — специальный механизм для «больших» файлов

Разберём оба случая и чёткую границу, когда какой способ использовать.

* * *

1\. Хранение файла напрямую (Binary)
====================================

MongoDB позволяет помещать файл в документ:

```
{ file: BinData(0, "<base64>") }
```

Это подходит для **небольших** файлов.

### Ограничения

1.  **Максимальный размер одного BSON-документа — 16 MB.**  
    Это означает:  
    **файл, помещённый в поле BinData, должен быть < 16 MB.**
2.  Практическая граница значительно ниже:
    *   оптимально **до 2–4 MB**;
    *   до 10 MB — возможно, но уже рискованно для производительности;
    *   ближе к 16 MB — **нельзя**, так как весь документ нельзя будет обновить/прочитать эффективно.

### Когда подходит:

*   аватары пользователей (50 KB – 300 KB)
*   PDF 100–500 KB
*   миниатюры изображений
*   небольшие бинарные блоки (сертификаты, зашифрованные токены)

### Минусы:

*   документ целиком загружается в память при чтении (даже если вам нужен только кусок файла)
*   сложно обновлять: обновление файла → обновление всего документа
*   данные плохо кешируются и индексируются

* * *

2\. GridFS — механизм хранения больших файлов
=============================================

GridFS автоматически делит файл на части (chunks):

*   по 255 KB каждая (по умолчанию)
*   хранит их в коллекции `fs.chunks`
*   метаданные — в коллекции `fs.files`

### Когда нужно использовать GridFS:

*   файл **16 MB или больше** — обязательно
*   файл **от ~5–10 MB и выше** — рекомендуется

### Примеры:

*   видео 50–500 MB
*   фотографии 20+ MB
*   большие PDF 10–50 MB
*   резервные копии, архивы, бинарные модели ML

### Плюсы GridFS:

*   сохраняет и отдаёт файлы частями: эффективно по памяти
*   можно стримить файл (не загружая целиком)
*   можно перезаписывать части без обновления всего документа
*   работает как CDN/файловый сервис внутри MongoDB

### Минусы:

*   сложнее в использовании чем BinData
*   дополнительные коллекции
*   требуется библиотека/драйвер (mongosh, Node.js, Python, etc.)

* * *

3\. Чёткая рекомендация (границы)
=================================

| Размер файла | Где хранить | Почему |
| --- | --- | --- |
| **0 – 100 KB** | Binary в документе | Легко, быстро, почти без overhead |
| **100 KB – 2 MB** | Binary | Нормально, но следите за ростом коллекции |
| **2 MB – 5 MB** | Binary — можно, но нежелательно | Документ тяжёлый, операции замедляются |
| **5 MB – 16 MB** | Binary — риск | Граница документа, возможны ошибки |
| **\>16 MB** | **GridFS обязательно** | MongoDB не поддерживает документы > 16 MB |
| **\>5–10 MB** | **Рекомендуется GridFS** | Производительность и удобство работы |

**Практическая граница: всё, что больше ≈5 MB — лучше отдавать в GridFS.**

* * *

4\. Примеры вставки файла
=========================

### Малый файл (Binary)

```
db.files.insertOne({
    filename: "avatar.png",
    data: BinData(0, "<base64>"),
    created_at: ISODate()
});
```

### Большой файл через GridFS (mongosh)

```
mongofiles --db=mydb put myvideo.mp4
```

или через драйвер (Node.js):

```
const bucket = new mongodb.GridFSBucket(db);
fs.createReadStream("bigfile.zip").pipe(bucket.openUploadStream("bigfile.zip"));
```

* * *

Итог
====

1.  **Документы в MongoDB ≤ 16 MB**, поэтому файлы больше этого размера нужно хранить через GridFS.
2.  **Небольшие файлы (до ~2 MB)** — удобно хранить прямо в документе (BinData).
3.  **Файлы 5–10 MB и больше** — технически можно хранить в документе, но правильно использовать GridFS.
4.  MongoDB **не предназначена** для хранения огромного количества крупных файлов без GridFS.

* * *

Если хотите, могу:

*   показать, как правильно создать GridFS-бакет в вашем приложении
*   написать пример кода для Python или Node.js
*   сделать совет: когда лучше вообще хранить файлы вне MongoDB (на диске, S3, MinIO)

## Response:
Ниже — **корректные практические примеры**, как вставить небольшой файл в MongoDB:

1.  Через **оболочку mongosh** (вставка BinData)
2.  Через **Compass** (GUI-интерфейс)

* * *

1\. Как ВСТАВИТЬ небольшой файл через mongosh
=============================================

MongoDB хранит файл в виде **BinData**, где данные записываются в Base64.

Алгоритм:

### Шаг 1. Преобразовать файл → Base64

Linux / macOS:

```
base64 avatar.png > avatar.b64
```

Windows PowerShell:

```
[Convert]::ToBase64String([IO.File]::ReadAllBytes("avatar.png")) > avatar.b64
```

Теперь `avatar.b64` содержит строку Base64.

### Шаг 2. Открыть файл и вставить в MongoDB

Открываете файл `avatar.b64`, копируете строку.

### Шаг 3. Вставка в оболочке mongosh:

```
db.files.insertOne({
    filename: "avatar.png",
    size: 12345,
    data: BinData(0, "<ВАШ_BASE64_ТЕКСТ>"),
    uploaded_at: ISODate()
});
```

Где:

*   `BinData(0, "...")` — **тип 0**, стандартный generic binary.
*   `<ВАШ_BASE64_ТЕКСТ>` — вставляете строку Base64.

### Пример:

```
db.files.insertOne({
    filename: "logo.png",
    data: BinData(0, "iVBORw0KGgoAAAANSUhEUgAAA..."),
    uploaded_at: ISODate()
});
```

Файл теперь хранится в документах коллекции `files`.

* * *

2\. Как ВСТАВИТЬ небольшой файл через MongoDB COMPASS
=====================================================

Compass позволяет вставлять бинарные данные, но **через JSON, который автоматически превращает base64 → BinData**.

Алгоритм:

### Шаг 1. Открыть коллекцию

Например: **files**

### Шаг 2. Нажать

**Insert Document → JSON Mode**

### Шаг 3. Вставить документ такого вида:

```
{
  "filename": "avatar.png",
  "data": {
    "$binary": {
      "base64": "iVBORw0KGgoAAAANSUhEUgAAA....",
      "subType": "00"
    }
  },
  "uploaded_at": { "$date": "2024-02-01T10:00:00Z" }
}
```

Compass автоматически преобразует это поле в BSON Binary.

### Где взять base64?

Сгенерировать так же, как и для shell.

* * *

3\. Что означает `"subType": "00"`?
===================================

Это тип Binary:

*   `"00"` — generic binary (обычный файл)
*   `"04"` — UUID
*   `"80"` — пользовательские типы

Для файлов всегда используют **"00"**.

* * *

